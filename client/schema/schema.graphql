# source: http://localhost:8080/graphql
# timestamp: Fri Jan 17 2020 10:42:01 GMT+0100 (Central European Standard Time)

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @id on FIELD_DEFINITION

input AddBoardInput {
  title: String!
  columns: [ColumnRef]
  order: [String]
}

type AddBoardPayload {
  board(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
}

input AddColumnInput {
  title: String!
  taskIds: [String]
}

type AddColumnPayload {
  column(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
}

input AddCommentInput {
  worker: WorkerRef
  content: String!
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
}

input AddProjectInput {
  title: String!
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  workers: [WorkerRef]
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input AddTagInput {
  title: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
}

input AddTaskInput {
  title: String!
  hours: Int!
  deadline: String!
  content: String!
  priority: Int!
  complete: Boolean!
  likes: [WorkerRef]
  comments: [CommentRef]
}

type AddTaskPayload {
  task(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input AddUserInput {
  username: String!
  password: String!
  location: String!
  roles: [WorkerRef]
  stars: [TaskRef]
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
}

input AddWorkerInput {
  name: String!
  availability: Int!
  user: UserRef!
  tags: [TagRef]
  tasks: [TaskRef]
}

type AddWorkerPayload {
  worker(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
}

type Board {
  id: ID
  title: String!
  columns(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  order: [String]
}

input BoardFilter {
  id: [ID!]
  not: BoardFilter
}

input BoardOrder {
  asc: BoardOrderable
  desc: BoardOrderable
  then: BoardOrder
}

enum BoardOrderable {
  title
  order
}

input BoardPatch {
  title: String
  columns: [ColumnRef]
  order: [String]
}

input BoardRef {
  id: ID
  title: String
  columns: [ColumnRef]
  order: [String]
}

type Column {
  id: ID
  title: String!
  taskIds: [String]
}

input ColumnFilter {
  id: [ID!]
  not: ColumnFilter
}

input ColumnOrder {
  asc: ColumnOrderable
  desc: ColumnOrderable
  then: ColumnOrder
}

enum ColumnOrderable {
  title
  taskIds
}

input ColumnPatch {
  title: String
  taskIds: [String]
}

input ColumnRef {
  id: ID
  title: String
  taskIds: [String]
}

type Comment {
  id: ID
  worker(filter: WorkerFilter): Worker
  content: String!
}

input CommentFilter {
  id: [ID!]
  not: CommentFilter
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  content
}

input CommentPatch {
  worker: WorkerRef
  content: String
}

input CommentRef {
  id: ID
  worker: WorkerRef
  content: String
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteBoardPayload {
  msg: String
}

type DeleteColumnPayload {
  msg: String
}

type DeleteCommentPayload {
  msg: String
}

type DeleteProjectPayload {
  msg: String
}

type DeleteTagPayload {
  msg: String
}

type DeleteTaskPayload {
  msg: String
}

type DeleteUserPayload {
  msg: String
}

type DeleteWorkerPayload {
  msg: String
}

enum DgraphIndex {
  int
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

type Mutation {
  addComment(input: [AddCommentInput!]!): AddCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  deleteComment(filter: CommentFilter!): DeleteCommentPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addTask(input: [AddTaskInput!]!): AddTaskPayload
  updateTask(input: UpdateTaskInput!): UpdateTaskPayload
  deleteTask(filter: TaskFilter!): DeleteTaskPayload
  addColumn(input: [AddColumnInput!]!): AddColumnPayload
  updateColumn(input: UpdateColumnInput!): UpdateColumnPayload
  deleteColumn(filter: ColumnFilter!): DeleteColumnPayload
  addBoard(input: [AddBoardInput!]!): AddBoardPayload
  updateBoard(input: UpdateBoardInput!): UpdateBoardPayload
  deleteBoard(filter: BoardFilter!): DeleteBoardPayload
  addWorker(input: [AddWorkerInput!]!): AddWorkerPayload
  updateWorker(input: UpdateWorkerInput!): UpdateWorkerPayload
  deleteWorker(filter: WorkerFilter!): DeleteWorkerPayload
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addProject(input: [AddProjectInput!]!): AddProjectPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  deleteProject(filter: ProjectFilter!): DeleteProjectPayload
}

type Project {
  id: ID
  title: String!
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  tasks(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  boards(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  workers(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
}

input ProjectFilter {
  id: [ID!]
  title: StringHashFilter
  and: ProjectFilter
  or: ProjectFilter
  not: ProjectFilter
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

enum ProjectOrderable {
  title
}

input ProjectPatch {
  title: String
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  workers: [WorkerRef]
}

input ProjectRef {
  id: ID
  title: String
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  workers: [WorkerRef]
}

type Query {
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  getTag(id: ID!): Tag
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  getTask(id: ID!): Task
  queryTask(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  getColumn(id: ID!): Column
  queryColumn(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  getBoard(id: ID!): Board
  queryBoard(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  getWorker(id: ID!): Worker
  queryWorker(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
  getUser(id: ID!): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input StringExactFilter {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  id: ID
  title: String!
}

input TagFilter {
  id: [ID!]
  not: TagFilter
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  title
}

input TagPatch {
  title: String
}

input TagRef {
  id: ID
  title: String
}

type Task {
  id: ID
  title: String!
  hours: Int!
  deadline: String!
  content: String!
  priority: Int!
  complete: Boolean!
  likes(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
}

input TaskFilter {
  id: [ID!]
  title: StringHashFilter
  and: TaskFilter
  or: TaskFilter
  not: TaskFilter
}

input TaskOrder {
  asc: TaskOrderable
  desc: TaskOrderable
  then: TaskOrder
}

enum TaskOrderable {
  title
  hours
  deadline
  content
  priority
}

input TaskPatch {
  title: String
  hours: Int
  deadline: String
  content: String
  priority: Int
  complete: Boolean
  likes: [WorkerRef]
  comments: [CommentRef]
}

input TaskRef {
  id: ID
  title: String
  hours: Int
  deadline: String
  content: String
  priority: Int
  complete: Boolean
  likes: [WorkerRef]
  comments: [CommentRef]
}

input UpdateBoardInput {
  filter: BoardFilter!
  set: BoardPatch
  remove: BoardPatch
}

type UpdateBoardPayload {
  board(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
}

input UpdateColumnInput {
  filter: ColumnFilter!
  set: ColumnPatch
  remove: ColumnPatch
}

type UpdateColumnPayload {
  column(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
}

input UpdateTaskInput {
  filter: TaskFilter!
  set: TaskPatch
  remove: TaskPatch
}

type UpdateTaskPayload {
  task(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
}

input UpdateWorkerInput {
  filter: WorkerFilter!
  set: WorkerPatch
  remove: WorkerPatch
}

type UpdateWorkerPayload {
  worker(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
}

type User {
  id: ID
  username: String!
  password: String!
  location: String!
  roles(filter: WorkerFilter, order: WorkerOrder, first: Int, offset: Int): [Worker]
  stars(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  and: UserFilter
  or: UserFilter
  not: UserFilter
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  username
  password
  location
}

input UserPatch {
  username: String
  password: String
  location: String
  roles: [WorkerRef]
  stars: [TaskRef]
}

input UserRef {
  id: ID
  username: String
  password: String
  location: String
  roles: [WorkerRef]
  stars: [TaskRef]
}

type Worker {
  id: ID
  name: String!
  availability: Int!
  user(filter: UserFilter): User!
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  tasks(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input WorkerFilter {
  id: [ID!]
  name: StringHashFilter
  and: WorkerFilter
  or: WorkerFilter
  not: WorkerFilter
}

input WorkerOrder {
  asc: WorkerOrderable
  desc: WorkerOrderable
  then: WorkerOrder
}

enum WorkerOrderable {
  name
  availability
}

input WorkerPatch {
  name: String
  availability: Int
  user: UserRef
  tags: [TagRef]
  tasks: [TaskRef]
}

input WorkerRef {
  id: ID
  name: String
  availability: Int
  user: UserRef
  tags: [TagRef]
  tasks: [TaskRef]
}
