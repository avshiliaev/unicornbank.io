# source: http://localhost:8080/graphql
# timestamp: Sat Jun 06 2020 19:06:08 GMT+0200 (Central European Summer Time)

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @id on FIELD_DEFINITION

input AddDeveloperInput {
  project: ProjectRef!
  name: String!
  user: [UserRef]
  entities: [EntityRef]
}

type AddDeveloperPayload {
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  numUids: Int
}

input AddEntityInput {
  project: ProjectRef!
  title: String!
  description: String!
  developers: [DeveloperRef]
  status: EntityStatus!
}

type AddEntityPayload {
  entity(filter: EntityFilter, order: EntityOrder, first: Int, offset: Int): [Entity]
  numUids: Int
}

input AddProjectInput {
  title: String!
  description: String!
  hosts: [UserRef]!
  developers: [DeveloperRef]
  entities: [EntityRef]
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input AddUserInput {
  username: String!
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteDeveloperPayload {
  msg: String
  numUids: Int
}

type DeleteEntityPayload {
  msg: String
  numUids: Int
}

type DeleteProjectPayload {
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  msg: String
  numUids: Int
}

type Developer {
  id: ID!
  project(filter: ProjectFilter): Project!
  name: String!
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  entities(filter: EntityFilter, order: EntityOrder, first: Int, offset: Int): [Entity]
}

input DeveloperFilter {
  id: [ID!]
  name: StringHashFilter
  and: DeveloperFilter
  or: DeveloperFilter
  not: DeveloperFilter
}

input DeveloperOrder {
  asc: DeveloperOrderable
  desc: DeveloperOrderable
  then: DeveloperOrder
}

enum DeveloperOrderable {
  name
}

input DeveloperPatch {
  project: ProjectRef
  name: String
  user: [UserRef]
  entities: [EntityRef]
}

input DeveloperRef {
  id: ID
  project: ProjectRef
  name: String
  user: [UserRef]
  entities: [EntityRef]
}

enum DgraphIndex {
  int
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
}

type Entity {
  id: ID!
  project(filter: ProjectFilter): Project!
  title: String!
  description: String!
  developers(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  status: EntityStatus!
}

input EntityFilter {
  id: [ID!]
  title: StringHashFilter
  and: EntityFilter
  or: EntityFilter
  not: EntityFilter
}

input EntityOrder {
  asc: EntityOrderable
  desc: EntityOrderable
  then: EntityOrder
}

enum EntityOrderable {
  title
  description
}

input EntityPatch {
  project: ProjectRef
  title: String
  description: String
  developers: [DeveloperRef]
  status: EntityStatus
}

input EntityRef {
  id: ID
  project: ProjectRef
  title: String
  description: String
  developers: [DeveloperRef]
  status: EntityStatus
}

enum EntityStatus {
  READY
  PENDING
  FAIL
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

type Mutation {
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addProject(input: [AddProjectInput!]!): AddProjectPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  deleteProject(filter: ProjectFilter!): DeleteProjectPayload
  addEntity(input: [AddEntityInput!]!): AddEntityPayload
  updateEntity(input: UpdateEntityInput!): UpdateEntityPayload
  deleteEntity(filter: EntityFilter!): DeleteEntityPayload
  addDeveloper(input: [AddDeveloperInput!]!): AddDeveloperPayload
  updateDeveloper(input: UpdateDeveloperInput!): UpdateDeveloperPayload
  deleteDeveloper(filter: DeveloperFilter!): DeleteDeveloperPayload
}

type Project {
  id: ID!
  title: String!
  description: String!
  hosts(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]!
  developers(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  entities(filter: EntityFilter, order: EntityOrder, first: Int, offset: Int): [Entity]
}

input ProjectFilter {
  id: [ID!]
  title: StringHashFilter
  and: ProjectFilter
  or: ProjectFilter
  not: ProjectFilter
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

enum ProjectOrderable {
  title
  description
}

input ProjectPatch {
  title: String
  description: String
  hosts: [UserRef]
  developers: [DeveloperRef]
  entities: [EntityRef]
}

input ProjectRef {
  id: ID
  title: String
  description: String
  hosts: [UserRef]
  developers: [DeveloperRef]
  entities: [EntityRef]
}

type Query {
  getUser(id: ID!): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  getEntity(id: ID!): Entity
  queryEntity(filter: EntityFilter, order: EntityOrder, first: Int, offset: Int): [Entity]
  getDeveloper(id: ID!): Developer
  queryDeveloper(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
}

input StringExactFilter {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input UpdateDeveloperInput {
  filter: DeveloperFilter!
  set: DeveloperPatch
  remove: DeveloperPatch
}

type UpdateDeveloperPayload {
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  numUids: Int
}

input UpdateEntityInput {
  filter: EntityFilter!
  set: EntityPatch
  remove: EntityPatch
}

type UpdateEntityPayload {
  entity(filter: EntityFilter, order: EntityOrder, first: Int, offset: Int): [Entity]
  numUids: Int
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type User {
  id: ID!
  username: String!
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  host(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  stars(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  and: UserFilter
  or: UserFilter
  not: UserFilter
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  username
}

input UserPatch {
  username: String
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}

input UserRef {
  id: ID
  username: String
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}
