# source: http://localhost:8080/graphql
# timestamp: Wed Apr 08 2020 21:06:15 GMT+0200 (Central European Summer Time)

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @hasInverse(field: String!) on FIELD_DEFINITION

input AddBoardInput {
  project: ProjectRef!
  title: String!
  columns: [ColumnRef]
  order: [String]
}

type AddBoardPayload {
  board(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  numUids: Int
}

input AddColumnInput {
  board: BoardRef!
  title: String!
  tasks: [TaskRef]
}

type AddColumnPayload {
  column(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  numUids: Int
}

input AddCommentInput {
  task: TaskRef!
  developer: DeveloperRef!
  content: String!
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddDeveloperInput {
  project: ProjectRef!
  name: String!
  availability: Int!
  user: [UserRef]
  tags: [TagRef]
  tasks: [TaskRef]
  liked: [TaskRef]
}

type AddDeveloperPayload {
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  numUids: Int
}

input AddProjectInput {
  title: String!
  hosts: [UserRef]!
  description: String!
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  developers: [DeveloperRef]
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input AddTagInput {
  title: String!
  project: ProjectRef!
  developers: [DeveloperRef]
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input AddTaskInput {
  project: ProjectRef!
  column: ColumnRef
  title: String!
  developers: [DeveloperRef]
  hours: Int!
  deadline: String!
  content: String!
  priority: Int!
  complete: Boolean!
  likes: [DeveloperRef]
  comments: [CommentRef]
}

type AddTaskPayload {
  task(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  numUids: Int
}

input AddUserInput {
  username: String!
  location: String!
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type Board {
  id: ID!
  project(filter: ProjectFilter): Project!
  title: String!
  columns(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  order: [String]
}

input BoardFilter {
  id: [ID!]
  not: BoardFilter
}

input BoardOrder {
  asc: BoardOrderable
  desc: BoardOrderable
  then: BoardOrder
}

enum BoardOrderable {
  title
  order
}

input BoardPatch {
  project: ProjectRef
  title: String
  columns: [ColumnRef]
  order: [String]
}

input BoardRef {
  id: ID
  project: ProjectRef
  title: String
  columns: [ColumnRef]
  order: [String]
}

type Column {
  id: ID!
  board(filter: BoardFilter): Board!
  title: String!
  tasks(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input ColumnFilter {
  id: [ID!]
  not: ColumnFilter
}

input ColumnOrder {
  asc: ColumnOrderable
  desc: ColumnOrderable
  then: ColumnOrder
}

enum ColumnOrderable {
  title
}

input ColumnPatch {
  board: BoardRef
  title: String
  tasks: [TaskRef]
}

input ColumnRef {
  id: ID
  board: BoardRef
  title: String
  tasks: [TaskRef]
}

type Comment {
  id: ID!
  task(filter: TaskFilter): Task!
  developer(filter: DeveloperFilter): Developer!
  content: String!
}

input CommentFilter {
  id: [ID!]
  not: CommentFilter
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  content
}

input CommentPatch {
  task: TaskRef
  developer: DeveloperRef
  content: String
}

input CommentRef {
  id: ID
  task: TaskRef
  developer: DeveloperRef
  content: String
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteBoardPayload {
  msg: String
  numUids: Int
}

type DeleteColumnPayload {
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  msg: String
  numUids: Int
}

type DeleteDeveloperPayload {
  msg: String
  numUids: Int
}

type DeleteProjectPayload {
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  msg: String
  numUids: Int
}

type DeleteTaskPayload {
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  msg: String
  numUids: Int
}

type Developer {
  id: ID!
  project(filter: ProjectFilter): Project!
  name: String!
  availability: Int!
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  tasks(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  liked(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
}

input DeveloperFilter {
  id: [ID!]
  name: StringHashFilter
  and: DeveloperFilter
  or: DeveloperFilter
  not: DeveloperFilter
}

input DeveloperOrder {
  asc: DeveloperOrderable
  desc: DeveloperOrderable
  then: DeveloperOrder
}

enum DeveloperOrderable {
  name
  availability
}

input DeveloperPatch {
  project: ProjectRef
  name: String
  availability: Int
  user: [UserRef]
  tags: [TagRef]
  tasks: [TaskRef]
  liked: [TaskRef]
}

input DeveloperRef {
  id: ID
  project: ProjectRef
  name: String
  availability: Int
  user: [UserRef]
  tags: [TagRef]
  tasks: [TaskRef]
  liked: [TaskRef]
}

enum DgraphIndex {
  int
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

type Mutation {
  addComment(input: [AddCommentInput!]!): AddCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  deleteComment(filter: CommentFilter!): DeleteCommentPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addTask(input: [AddTaskInput!]!): AddTaskPayload
  updateTask(input: UpdateTaskInput!): UpdateTaskPayload
  deleteTask(filter: TaskFilter!): DeleteTaskPayload
  addColumn(input: [AddColumnInput!]!): AddColumnPayload
  updateColumn(input: UpdateColumnInput!): UpdateColumnPayload
  deleteColumn(filter: ColumnFilter!): DeleteColumnPayload
  addBoard(input: [AddBoardInput!]!): AddBoardPayload
  updateBoard(input: UpdateBoardInput!): UpdateBoardPayload
  deleteBoard(filter: BoardFilter!): DeleteBoardPayload
  addDeveloper(input: [AddDeveloperInput!]!): AddDeveloperPayload
  updateDeveloper(input: UpdateDeveloperInput!): UpdateDeveloperPayload
  deleteDeveloper(filter: DeveloperFilter!): DeleteDeveloperPayload
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addProject(input: [AddProjectInput!]!): AddProjectPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  deleteProject(filter: ProjectFilter!): DeleteProjectPayload
}

type Project {
  id: ID!
  title: String!
  hosts(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]!
  description: String!
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  tasks(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  boards(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  developers(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
}

input ProjectFilter {
  id: [ID!]
  title: StringHashFilter
  and: ProjectFilter
  or: ProjectFilter
  not: ProjectFilter
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

enum ProjectOrderable {
  title
  description
}

input ProjectPatch {
  title: String
  hosts: [UserRef]
  description: String
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  developers: [DeveloperRef]
}

input ProjectRef {
  id: ID
  title: String
  hosts: [UserRef]
  description: String
  tags: [TagRef]
  tasks: [TaskRef]
  boards: [BoardRef]
  developers: [DeveloperRef]
}

type Query {
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  getTag(id: ID!): Tag
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  getTask(id: ID!): Task
  queryTask(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  getColumn(id: ID!): Column
  queryColumn(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  getBoard(id: ID!): Board
  queryBoard(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  getDeveloper(id: ID!): Developer
  queryDeveloper(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  getUser(id: ID!): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input StringExactFilter {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tag {
  id: ID!
  title: String!
  project(filter: ProjectFilter): Project!
  developers(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
}

input TagFilter {
  id: [ID!]
  not: TagFilter
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  title
}

input TagPatch {
  title: String
  project: ProjectRef
  developers: [DeveloperRef]
}

input TagRef {
  id: ID
  title: String
  project: ProjectRef
  developers: [DeveloperRef]
}

type Task {
  id: ID!
  project(filter: ProjectFilter): Project!
  column(filter: ColumnFilter): Column
  title: String!
  developers(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  hours: Int!
  deadline: String!
  content: String!
  priority: Int!
  complete: Boolean!
  likes(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
}

input TaskFilter {
  id: [ID!]
  title: StringHashFilter
  and: TaskFilter
  or: TaskFilter
  not: TaskFilter
}

input TaskOrder {
  asc: TaskOrderable
  desc: TaskOrderable
  then: TaskOrder
}

enum TaskOrderable {
  title
  hours
  deadline
  content
  priority
}

input TaskPatch {
  project: ProjectRef
  column: ColumnRef
  title: String
  developers: [DeveloperRef]
  hours: Int
  deadline: String
  content: String
  priority: Int
  complete: Boolean
  likes: [DeveloperRef]
  comments: [CommentRef]
}

input TaskRef {
  id: ID
  project: ProjectRef
  column: ColumnRef
  title: String
  developers: [DeveloperRef]
  hours: Int
  deadline: String
  content: String
  priority: Int
  complete: Boolean
  likes: [DeveloperRef]
  comments: [CommentRef]
}

input UpdateBoardInput {
  filter: BoardFilter!
  set: BoardPatch
  remove: BoardPatch
}

type UpdateBoardPayload {
  board(filter: BoardFilter, order: BoardOrder, first: Int, offset: Int): [Board]
  numUids: Int
}

input UpdateColumnInput {
  filter: ColumnFilter!
  set: ColumnPatch
  remove: ColumnPatch
}

type UpdateColumnPayload {
  column(filter: ColumnFilter, order: ColumnOrder, first: Int, offset: Int): [Column]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateDeveloperInput {
  filter: DeveloperFilter!
  set: DeveloperPatch
  remove: DeveloperPatch
}

type UpdateDeveloperPayload {
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  numUids: Int
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input UpdateTaskInput {
  filter: TaskFilter!
  set: TaskPatch
  remove: TaskPatch
}

type UpdateTaskPayload {
  task(filter: TaskFilter, order: TaskOrder, first: Int, offset: Int): [Task]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

type User {
  id: ID!
  username: String!
  location: String!
  developer(filter: DeveloperFilter, order: DeveloperOrder, first: Int, offset: Int): [Developer]
  host(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  stars(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  and: UserFilter
  or: UserFilter
  not: UserFilter
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  username
  location
}

input UserPatch {
  username: String
  location: String
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}

input UserRef {
  id: ID
  username: String
  location: String
  developer: [DeveloperRef]
  host: [ProjectRef]
  stars: [ProjectRef]
}
